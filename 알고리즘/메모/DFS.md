[TOC]



## 동적 계획(Dynamic Programming) 알고리즘

> 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.



```
동적 계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에, 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.
```



- 문제를 부분 문제로 분할한다.
- 부분 문제로 나누는 일을 끝냈으면, 가장 작은 부분 문제부터 해를 구한다.
- 그 결과는 테이블에 저잘하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구한다.



**memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현하는 것이 성능 면에서 보다 효율적이다.**

재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문이다.



**DP의 핵심 기술은 memoization이다. 미리 계산한 값을 뽑아 사용하는 기술.**

<hr>



## DFS (깊이우선탐색)

> 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법.



비선형 구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다.

*(선형은 배열)*



- 깊이 우선 탐색 (Depth First Search, DFS)
- 너비 우선 탐색 (Breadth First Search, BFS)

**가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용**



`DFS 알고리즘 구현`

- stack을 직접 만들어서 사용 (속도는 빠르다)
- 재귀 (일반적으로 사용함.) 
  - 스택이 다 비워져야한다. (= 모든 노드를 방문하여 시작점으로 다시 돌아온다. )

**깊이 우선 탐색이란, 시작점이랑 먼 곳을 찾아가는 탐색**

방향우선탐색...

- 재귀 : 이전에 방문 정보를 가지고 있고 리턴 하면됨. 



## DFS 알고리즘 구현

```python
# V : 정덤 개수 (node) E: 간선 개수 (Edge)
V, E = map(int, input().split())

# 인접행렬
adj = [[0] * (V+1) for _ in range(V+1)]
# node의 번호를 index로 이용해야 하기 때문에

# 간선정보
tmp = list(map(int, input().split()))

# 인접행렬 기록
for i in range(E):
    n1 = tmp[i*2]
    n2 = tmp[i*2+1]

    # 방향성이 없는 무방향 그래프. 그래프의 성질을 정하는 유일한 코드
    adj[n1][n2] = 1
    adj[n2][n1] = 1

# 반복구조의 깊이우선탐색


def dfs(s, adj):
    # 초기화, 스택생성, visited[] (방문표시) 생성 및 초기화
    visited = [0]*(V+1)  # visited 생성
    stack = [s]  # 스택 생성, 시작노드 push()

    # stack=[]
    # stack.append(s) # push()

    # 반복
    while stack:  # stack이 비어있지 않으면 반복
        # stack은 다음번에 탐색 할 번호가 담겨져있다.
        n = stack.pop()  # 탐색할 노드 선택
        print(n)  # n번 노드에서 할 일. 방문순서대로 출력
        visited[s] = 1
        # n에 인접하고 방문 안한 노드 찾기
        for i in range(V+1):
            # i가 n에 인접하고, 미방문이면
            if adj[n][i] == 1 and visited[i] == 0:
                stack.append(i)
                visited[i] = 1


dfs(1, adj)
```

```
1
3
5
6
7
4
2
```

